"""
Security utilities for playbook execution workflow (encryption + webhook signatures).
"""
from __future__ import annotations

import base64
import hmac
import hashlib
import json
import logging
import os
from functools import wraps
from typing import Any, Dict, Optional

from cryptography.fernet import Fernet
from flask import request, jsonify, g

from extensions import db

logger = logging.getLogger(__name__)


def _get_cipher() -> Fernet:
    """Return a cached Fernet cipher instance."""
    if not hasattr(_get_cipher, "_cipher"):
        key = os.getenv("ENCRYPTION_KEY")
        if not key:
            raise RuntimeError(
                "ENCRYPTION_KEY environment variable not set. "
                "Generate with: python -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\""
            )
        _get_cipher._cipher = Fernet(key.encode())  # type: ignore[attr-defined]
    return _get_cipher._cipher  # type: ignore[attr-defined]


def encrypt_credential(credential: str) -> str:
    """Encrypt sensitive credential strings for storage."""
    cipher = _get_cipher()
    encrypted = cipher.encrypt(credential.encode("utf-8"))
    return base64.b64encode(encrypted).decode("utf-8")


def decrypt_credential(encrypted_credential: str) -> str:
    """Decrypt an encrypted credential back to plain text."""
    cipher = _get_cipher()
    decoded = base64.b64decode(encrypted_credential.encode("utf-8"))
    decrypted = cipher.decrypt(decoded)
    return decrypted.decode("utf-8")


def generate_webhook_secret() -> str:
    """Generate a random webhook secret string."""
    return base64.urlsafe_b64encode(os.urandom(32)).decode("utf-8").rstrip("=")


def generate_webhook_signature(payload: Dict[str, Any], secret: str) -> str:
    """Generate an HMAC-SHA256 signature for a JSON payload."""
    payload_json = json.dumps(payload, sort_keys=True).encode("utf-8")
    signature = hmac.new(secret.encode("utf-8"), payload_json, hashlib.sha256).hexdigest()
    return signature


def verify_webhook_signature(payload_bytes: bytes, signature: str, secret: str) -> bool:
    """Verify a signature generated by `generate_webhook_signature`."""
    expected_signature = hmac.new(
        secret.encode("utf-8"),
        payload_bytes,
        hashlib.sha256,
    ).hexdigest()
    return hmac.compare_digest(signature, expected_signature)


def require_webhook_signature(handler):
    """
    Flask decorator that verifies webhook signatures for inbound n8n callbacks.
    Expects:
      - Header `X-Webhook-Signature`
      - JSON payload containing `execution_id`
    Populates:
      - `g.verified_execution`
      - `g.verified_customer_id`
    """
    from models import PlaybookExecution, CustomerWorkflowConfig  # late import to avoid circular deps

    @wraps(handler)
    def wrapper(*args, **kwargs):
        signature = request.headers.get("X-Webhook-Signature")
        if not signature:
            logger.warning("Webhook callback missing signature header")
            return jsonify({"error": "Missing signature"}), 401

        try:
            payload = request.get_json(force=True)
        except Exception as exc:  # pragma: no cover - defensive
            logger.error("Invalid JSON payload on webhook callback: %s", exc)
            return jsonify({"error": "Invalid JSON"}), 400

        execution_id = payload.get("execution_id")
        if not execution_id:
            return jsonify({"error": "Missing execution_id"}), 400

        execution: Optional[PlaybookExecution] = PlaybookExecution.query.filter_by(
            execution_id=execution_id
        ).first()
        if not execution:
            logger.error("Webhook callback for unknown execution %s", execution_id)
            return jsonify({"error": "Execution not found"}), 404

        config: Optional[CustomerWorkflowConfig] = CustomerWorkflowConfig.query.filter_by(
            customer_id=execution.customer_id
        ).first()
        if not config or not config.webhook_secret_encrypted:
            logger.error("No webhook secret configured for customer %s", execution.customer_id)
            return jsonify({"error": "Webhook not configured"}), 500

        secret = decrypt_credential(config.webhook_secret_encrypted)
        payload_bytes = request.get_data()

        if not verify_webhook_signature(payload_bytes, signature, secret):
            # Grace period handling using rotated secret
            if config.webhook_secret_old_encrypted and config.webhook_secret_grace_period_until:
                try:
                    from datetime import datetime

                    if datetime.utcnow() <= config.webhook_secret_grace_period_until:
                        old_secret = decrypt_credential(config.webhook_secret_old_encrypted)
                        if verify_webhook_signature(payload_bytes, signature, old_secret):
                            logger.info(
                                "Webhook signature matched rotated secret (execution=%s)", execution_id
                            )
                        else:
                            raise ValueError("Rotated secret mismatch")
                    else:
                        raise ValueError("Grace period expired")
                except Exception as exc:
                    logger.warning(
                        "Invalid webhook signature for execution %s: %s", execution_id, exc
                    )
                    return jsonify({"error": "Invalid signature"}), 401
            else:
                logger.warning(
                    "Invalid webhook signature for execution %s (no grace secret)", execution_id
                )
                return jsonify({"error": "Invalid signature"}), 401

        g.verified_execution = execution
        g.verified_customer_id = execution.customer_id
        return handler(*args, **kwargs)

    return wrapper


def rotate_webhook_secret(config, new_secret: Optional[str] = None) -> str:
    """
    Rotate a customer's webhook secret, storing the old secret for a grace period.
    """
    from datetime import datetime, timedelta

    secret = new_secret or generate_webhook_secret()
    config.webhook_secret_old_encrypted = config.webhook_secret_encrypted
    config.webhook_secret_encrypted = encrypt_credential(secret)
    config.webhook_secret_rotated_at = datetime.utcnow()
    config.webhook_secret_grace_period_until = datetime.utcnow() + timedelta(hours=24)
    db.session.add(config)
    db.session.commit()
    return secret

